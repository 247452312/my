/*
 Navicat Premium Data Transfer

 Source Server         : mac
 Source Server Type    : MySQL
 Source Server Version : 80024
 Source Host           : prod:3306
 Source Schema         : my_algorithm

 Target Server Type    : MySQL
 Target Server Version : 80024
 File Encoding         : 65001

 Date: 14/02/2022 09:27:00
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for sys_algorithm
-- ----------------------------
DROP TABLE IF EXISTS `sys_algorithm`;
CREATE TABLE `sys_algorithm`  (
  `id` bigint(0) NOT NULL,
  `create_date` bigint(0) NULL DEFAULT NULL,
  `create_user` bigint(0) NULL DEFAULT NULL,
  `delete_flag` bit(1) NULL DEFAULT NULL,
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `update_date` bigint(0) NULL DEFAULT NULL,
  `update_user` bigint(0) NULL DEFAULT NULL,
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '算法名称',
  `need_file` tinyint(1) NULL DEFAULT NULL COMMENT '是否需要文件',
  `model_file_path` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '模型文件所在地',
  `body` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '算法体',
  `language_type` int(0) NULL DEFAULT NULL COMMENT '语言类型',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '算法表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_algorithm
-- ----------------------------
INSERT INTO `sys_algorithm` VALUES (1, 1, 1, b'0', '1', 1, 1, '测试算法', 0, NULL, '{\r\n    \"H.java\": \"package indi.uhyils;\\n public class H {\\n    public int add(int a, int b) {\\n        return a + b;\\n    }\\n}\",\r\n    \"Algorithm.java\": \"import indi.uhyils.H;\\nimport indi.uhyils.util.IdUtil;\\nimport indi.uhyils.util.SpringUtil;\\n public class Algorithm {\\n\\n    public long cell(int a, int b) { IdUtil bean = SpringUtil.getBean(IdUtil.class); long l = bean.newId(); return l; }\\n}\"\r\n}', NULL);
INSERT INTO `sys_algorithm` VALUES (2, 1, 1, b'0', '1', 1, 1, '遗传算法', 0, NULL, '{\"GeneticAlgorithm.java\":\"package indi.uhyils.util.genetic;\\n\\nimport indi.uhyils.util.LogUtil;\\nimport indi.uhyils.util.genetic.core.AbstractsInitialization;\\nimport indi.uhyils.util.genetic.core.DnaData;\\nimport indi.uhyils.util.genetic.core.FitnessFunction;\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.Comparator;\\nimport java.util.HashMap;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Objects;\\n\\n/**\\n * 遗传算法\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 07时55分\\n */\\npublic class GeneticAlgorithm {\\n\\n    /**\\n     * 种群数量\\n     */\\n    private Integer maxNum;\\n\\n    /**\\n     * 变异概率\\n     */\\n    private Double mutationProbability;\\n\\n    /**\\n     * 适应函数\\n     */\\n    private FitnessFunction fitnessFunction;\\n\\n    /**\\n     * 种群硬性约束\\n     */\\n    private AbstractsInitialization initialization;\\n\\n    /**\\n     * 增长因子\\n     */\\n    private Double growthRate;\\n\\n    /**\\n     * 不变异比例\\n     */\\n    private Double nonVariationRatio;\\n\\n    /**\\n     * 种群中所有的个体\\n     * 数量固定为种群数量最大值的1.5倍,其中多出来的0.5用来保证杂交后多出来的个体\\n     */\\n    private List<DnaData> data;\\n\\n    /**\\n     * 初始化种群\\n     *\\n     * @param maxNum              种群数量->种群每次迭代完成总会保持这个数量\\n     * @param mutationProbability 个体的变异概率 -> 每次变异时不是每一个个体都会变异\\n     * @param fitnessFunction     适应函数 -> 关键 决定这个个体是否适应这个世界\\n     * @param initialization      种群硬性约束 -> 初始化,交配,变异时将个体的值约束在一定的范围内,防止超出导致不可计算\\n     * @param growthRate          增长因子 -> 每次种群交配的比例\\n     * @param nonVariationRatio   不变异比例->最好的那一批个体不会发生变异,保存全局最优解\\n     */\\n    public GeneticAlgorithm(Integer maxNum, Double mutationProbability, FitnessFunction fitnessFunction, AbstractsInitialization initialization, Double growthRate, Double nonVariationRatio) {\\n        this.maxNum = maxNum;\\n        this.mutationProbability = mutationProbability;\\n        this.fitnessFunction = fitnessFunction;\\n        this.initialization = initialization;\\n        this.growthRate = growthRate;\\n        this.nonVariationRatio = nonVariationRatio;\\n    }\\n\\n    /**\\n     * 初始化种群\\n     */\\n    public void init(Double distance, Double... doubles) {\\n        getInitialization().setRandomFactor(doubles);\\n        getInitialization().setDistance(distance);\\n        this.data = new ArrayList<>(maxNum);\\n        for (int i = 0; i < maxNum; i++) {\\n            data.add(initialization.random());\\n        }\\n    }\\n\\n    /**\\n     * 迭代1次\\n     */\\n    public void iteration() {\\n        // 洗牌算法,打乱数组\\n        Collections.shuffle(data);\\n        // 杂交,孕育下一代并添加到数组中\\n        for (int i = 0; i < maxNum * growthRate; i++) {\\n            DnaData one = this.data.get(i * 2);\\n            DnaData two = this.data.get(i * 2 + 1);\\n            DnaData hybridization = initialization.hybridization(one, two);\\n            data.add(hybridization);\\n        }\\n        // 根据适应度排序  0->最适应 1-> 最不适应 从小到大排序\\n        Collections.sort(data, Comparator.comparing(o -> fitnessFunction.getFitness(o)));\\n        // 变异 最适应环境的那一批不变异\\n        for (int i = new Double(maxNum * nonVariationRatio).intValue(); i < data.size(); i++) {\\n            initialization.variation(data.get(i), mutationProbability);\\n        }\\n        // 排序\\n        Collections.sort(data, Comparator.comparing(o -> fitnessFunction.getFitness(o)));\\n        // 自然选择\\n        Iterator<DnaData> iterator = data.iterator();\\n        int i = 0;\\n        while (iterator.hasNext()) {\\n            iterator.next();\\n            if (i > maxNum) {\\n                iterator.remove();\\n            }\\n            i++;\\n        }\\n    }\\n\\n    /**\\n     * 迭代\\n     *\\n     * @param count 迭代次数100-500\\n     */\\n    public void iteration(Integer count) {\\n        for (int i = 0; i < count; i++) {\\n            iteration();\\n            LogUtil.info(this, \\\"遍历第\\\" + (i + 1) + \\\"遍\\\");\\n        }\\n    }\\n\\n\\n    public Integer getMaxNum() {\\n        return maxNum;\\n    }\\n\\n    public void setMaxNum(Integer maxNum) {\\n        this.maxNum = maxNum;\\n    }\\n\\n    public Double getMutationProbability() {\\n        return mutationProbability;\\n    }\\n\\n    public void setMutationProbability(Double mutationProbability) {\\n        this.mutationProbability = mutationProbability;\\n    }\\n\\n    public FitnessFunction getFitnessFunction() {\\n        return fitnessFunction;\\n    }\\n\\n    public void setFitnessFunction(FitnessFunction fitnessFunction) {\\n        this.fitnessFunction = fitnessFunction;\\n    }\\n\\n    public List<DnaData> getData() {\\n        return data;\\n    }\\n\\n    public void setData(List<DnaData> data) {\\n        this.data = data;\\n    }\\n\\n    public AbstractsInitialization getInitialization() {\\n        return initialization;\\n    }\\n\\n    public void setInitialization(AbstractsInitialization initialization) {\\n        this.initialization = initialization;\\n    }\\n\\n    public Double getGrowthRate() {\\n        return growthRate;\\n    }\\n\\n    public void setGrowthRate(Double growthRate) {\\n        this.growthRate = growthRate;\\n    }\\n\\n    public Double getNonVariationRatio() {\\n        return nonVariationRatio;\\n    }\\n\\n    public void setNonVariationRatio(Double nonVariationRatio) {\\n        this.nonVariationRatio = nonVariationRatio;\\n    }\\n\\n    /**\\n     * 获取迭代后的结果\\n     *\\n     * @return 结果\\n     */\\n    public HashMap<DnaData, Integer> getResult() {\\n        // 排序\\n        Collections.sort(data, Comparator.comparing(o -> fitnessFunction.getFitness(o)));\\n        HashMap<DnaData, Integer> result = new HashMap<>(16);\\n        for (DnaData datum : data) {\\n            // 默认里面没有datum相近的点\\n            Boolean b = Boolean.TRUE;\\n            for (Map.Entry<DnaData, Integer> entity : result.entrySet()) {\\n                DnaData key = entity.getKey();\\n                Double distance = initialization.getDistance(datum, key);\\n                // 获取的值小于设定的值\\n                if (initialization.getDistance() > distance) {\\n                    b = false;\\n                    result.put(key, result.get(key) + 1);\\n                    break;\\n                }\\n            }\\n            // 遍历完成之后依旧没有相近的值\\n            if (b) {\\n                result.put(datum, 1);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) {\\n            return Boolean.TRUE;\\n        }\\n        if (o == null || getClass() != o.getClass()) {\\n            return Boolean.FALSE;\\n        }\\n        GeneticAlgorithm that = (GeneticAlgorithm) o;\\n        return Objects.equals(maxNum, that.maxNum) &&\\n               Objects.equals(mutationProbability, that.mutationProbability) &&\\n               Objects.equals(fitnessFunction, that.fitnessFunction) &&\\n               Objects.equals(initialization, that.initialization) &&\\n               Objects.equals(growthRate, that.growthRate) &&\\n               Objects.equals(nonVariationRatio, that.nonVariationRatio) &&\\n               Objects.equals(data, that.data);\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(maxNum, mutationProbability, fitnessFunction, initialization, growthRate, nonVariationRatio, data);\\n    }\\n}\",\"遗传算法\":\"\",\"AbstractsInitialization.java\":\"package indi.uhyils.util.genetic.core;\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Random;\\n\\n/**\\n * DNA结构\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 13时46分\\n */\\npublic abstract class AbstractsInitialization implements DataInitialization<DnaData> {\\n\\n    protected Random random = new Random();\\n\\n    /**\\n     * 随机因子\\n     */\\n    protected Double[] range;\\n\\n    /**\\n     * 多远距离算同一个点\\n     */\\n    private Double distance;\\n\\n    @Override\\n    public Double getDistance() {\\n        return distance;\\n    }\\n\\n    @Override\\n    public void setDistance(Double distance) {\\n        this.distance = distance;\\n    }\\n\\n    @Override\\n    public DnaData random() {\\n        DnaData quadraticData = new DnaData();\\n        ArrayList<DoubleGene> genes = new ArrayList<>();\\n        // 添加a\\n        genes.add(DoubleGene.build(range[0], range[1]));\\n        // 添加b\\n        genes.add(DoubleGene.build(range[2], range[3]));\\n        quadraticData.setGenes(genes);\\n        return quadraticData;\\n    }\\n\\n    /**\\n     * 设置随机约束\\n     *\\n     * @param range 种群约束\\n     */\\n    public void setRandomFactor(Double... range) {\\n        this.range = range;\\n    }\\n\\n    @Override\\n    public DnaData hybridization(DnaData one, DnaData otherOne) {\\n        List<DoubleGene> oneGenes = one.getGenes();\\n        List<DoubleGene> otherOneGenes = otherOne.getGenes();\\n        // one基因对取第ai条基因\\n        int ai = random.nextInt(2);\\n        // two基因对取第bi条基因\\n        int bi = random.nextInt(2);\\n        List<DoubleGene> result = new ArrayList<>();\\n        // 每一个基因只和自己杂交\\n        for (int i = 0; i < oneGenes.size(); i++) {\\n            DoubleGene oneGenesDoubleGene = oneGenes.get(i);\\n            DoubleGene otherOneGenesDoubleGene = otherOneGenes.get(i);\\n            Gene oneResult;\\n            Gene otherOneResult;\\n            if (ai == 0) {\\n                oneResult = (Gene) oneGenesDoubleGene.getOne().clone();\\n            } else {\\n                oneResult = (Gene) oneGenesDoubleGene.getTwo().clone();\\n            }\\n            if (bi == 0) {\\n                otherOneResult = (Gene) otherOneGenesDoubleGene.getOne().clone();\\n            } else {\\n                otherOneResult = (Gene) otherOneGenesDoubleGene.getTwo().clone();\\n            }\\n            DoubleGene e = new DoubleGene();\\n            e.setOne(oneResult);\\n            e.setTwo(otherOneResult);\\n            result.add(e);\\n        }\\n        DnaData quadraticData = new DnaData();\\n        quadraticData.setGenes(result);\\n        return quadraticData;\\n    }\\n}\",\"Data.java\":\"package indi.uhyils.util.genetic.core;\\n\\n/**\\n * 遗传算法专用数据最好是带结构的数据适合这样的方法\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 07时46分\\n */\\npublic interface Data extends Cloneable {\\n\\n}\",\"DnaData.java\":\"package indi.uhyils.util.genetic.core;\\n\\nimport java.util.List;\\nimport java.util.Objects;\\n\\n/**\\n * 环状DNA数据\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 09时27分\\n */\\npublic class DnaData implements Data {\\n\\n    /**\\n     * 基因对们\\n     */\\n    private List<DoubleGene> genes;\\n\\n\\n    public List<DoubleGene> getGenes() {\\n        return genes;\\n    }\\n\\n    public void setGenes(List<DoubleGene> genes) {\\n        this.genes = genes;\\n    }\\n\\n    public Double getA() {\\n        DoubleGene doubleDoubleGene = getGenes().get(0);\\n        return doubleDoubleGene.get();\\n    }\\n\\n    public Double getB() {\\n        DoubleGene doubleDoubleGene = getGenes().get(1);\\n        return doubleDoubleGene.get();\\n    }\\n\\n    @Override\\n    public boolean equals(Object o) {\\n        if (this == o) {\\n            return Boolean.TRUE;\\n        }\\n        if (o == null || getClass() != o.getClass()) {\\n            return Boolean.FALSE;\\n        }\\n        DnaData dnaData = (DnaData) o;\\n        return Objects.equals(genes, dnaData.genes);\\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return Objects.hash(genes);\\n    }\\n}\",\"DataInitialization.java\":\"package indi.uhyils.util.genetic.core;\\n\\n/**\\n * 种群操作工具\\n *\\n * @param <T> 遗传算法中的个体\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 08时14分\\n */\\npublic interface DataInitialization<T extends Data> {\\n\\n    /**\\n     * 获取设置好的欧氏距离\\n     *\\n     * @return\\n     */\\n    Double getDistance();\\n\\n    /**\\n     * 设置离得近的个体可以看做一个个体的最小值\\n     *\\n     * @param distance\\n     */\\n    void setDistance(Double distance);\\n\\n    /**\\n     * 随机初始化种群\\n     *\\n     * @return 随机出来的一个东西\\n     */\\n    T random();\\n\\n\\n    /**\\n     * 杂交\\n     * {@ps 允许自交将优秀的基因遗传下去}\\n     *\\n     * @param one      一个data\\n     * @param otherOne 另一个data\\n     *\\n     * @return 下一代\\n     */\\n    T hybridization(T one, T otherOne);\\n\\n    /**\\n     * 在判断两个个体之间是不是一个点时计算的欧氏距离\\n     *\\n     * @return 两个点之间的距离\\n     */\\n    Double getDistance(T one, T tow);\\n\\n    /**\\n     * 变异\\n     *\\n     * @param data                要变异的种群\\n     * @param mutationProbability 变异概率\\n     */\\n    void variation(T data, Double mutationProbability);\\n}\",\"DoubleGene.java\":\"package indi.uhyils.util.genetic.core;\\n\\nimport java.util.Random;\\n\\n/**\\n * 一对基因\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 09时30分\\n */\\npublic class DoubleGene {\\n\\n    public static Random random = new Random();\\n\\n    /**\\n     * 第一个基因\\n     */\\n    private Gene one;\\n\\n    /**\\n     * 第二个基因\\n     */\\n    private Gene two;\\n\\n    /**\\n     * 创建的基因的值在t1到t2之间\\n     *\\n     * @param min\\n     * @param max\\n     *\\n     * @return\\n     */\\n    public static DoubleGene build(Double min, Double max) {\\n        DoubleGene tDoubleGene = new DoubleGene();\\n        tDoubleGene.setOne(new Gene(Gene.getRandomBool(), Gene.getRandomT(min, max)));\\n        tDoubleGene.setTwo(new Gene(Gene.getRandomBool(), Gene.getRandomT(min, max)));\\n        return tDoubleGene;\\n    }\\n\\n\\n    public Gene getOne() {\\n        return one;\\n    }\\n\\n    public void setOne(Gene one) {\\n        this.one = one;\\n    }\\n\\n    public Gene getTwo() {\\n        return two;\\n    }\\n\\n    public void setTwo(Gene two) {\\n        this.two = two;\\n    }\\n\\n\\n    /**\\n     * 随机获取第一个还是第二个\\n     *\\n     * @return 获取到的基因\\n     */\\n    public Gene getRandomGene() {\\n        int i = random.nextInt(2);\\n        if (i == 0) {\\n            return one;\\n        }\\n        return two;\\n    }\\n\\n\\n    public Double get() {\\n        Boolean dominance = one.getDominance();\\n        if (dominance) {\\n            return one.getValue();\\n        } else if (two.getDominance()) {\\n            return two.getValue();\\n        } else {\\n            return one.getValue();\\n        }\\n    }\\n\\n    @Override\\n    public String toString() {\\nStringBuilder sb = new StringBuilder(\\\"{\\\");\\n        sb.append(\\\"            \\\\\\\"one\\\\\\\":\\\")\\n          .append(one);\\n        if (two != null) {\\n            sb.append(\\\",            \\\\\\\"two\\\\\\\":\\\")\\n              .append(two);\\n        }\\n        sb.append(\'}\');\\n        return sb.toString();\\n    }\\n}\",\"FitnessFunction.java\":\"package indi.uhyils.util.genetic.core;\\n\\n/**\\n * 适应函数\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 07时57分\\n */\\npublic interface FitnessFunction<T extends Data> {\\n\\n    /**\\n     * 获取种群个体的适应度\\n     *\\n     * @param data 个体\\n     *\\n     * @return 适应度\\n     */\\n    Double getFitness(T data);\\n}\",\"Gene.java\":\"package indi.uhyils.util.genetic.core;\\n\\nimport java.util.Random;\\n\\n/**\\n * 基因\\n *\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 09时28分\\n */\\npublic class Gene implements Cloneable {\\n\\n    public static Random random = new Random();\\n\\n    /**\\n     * 显性\\n     */\\n    private Boolean dominance;\\n\\n    /**\\n     * 值\\n     */\\n    private Double value;\\n\\n    public Gene(Boolean dominance, Double value) {\\n        this.dominance = dominance;\\n        this.value = value;\\n    }\\n\\n    public Gene() {\\n    }\\n\\n    public static Boolean getRandomBool() {\\n        int i = random.nextInt(2);\\n        if (i == 0) {\\n            return Boolean.FALSE;\\n        }\\n        return Boolean.TRUE;\\n    }\\n\\n    public static Double getRandomT(Double min, Double max) {\\n        double v = random.nextDouble();\\n        return min + (max - min) * v;\\n\\n    }\\n\\n    public Boolean getDominance() {\\n        return dominance;\\n    }\\n\\n    public void setDominance(Boolean dominance) {\\n        this.dominance = dominance;\\n    }\\n\\n    public Double getValue() {\\n        return value;\\n    }\\n\\n    public void setValue(Double value) {\\n        this.value = value;\\n    }\\n\\n    @Override\\n    public String toString() {\\nStringBuilder sb = new StringBuilder(\\\"{\\\");\\n        sb.append(\\\"            \\\\\\\"dominance\\\\\\\":\\\")\\n          .append(dominance);\\n        if (value != null) {\\n            sb.append(\\\",            \\\\\\\"value\\\\\\\":\\\")\\n              .append(value);\\n        }\\n        sb.append(\'}\');\\n        return sb.toString();\\n    }\\n\\n    @Override\\n    public Object clone() {\\n        Gene objectGene = new Gene();\\n        objectGene.setValue(this.getValue());\\n        objectGene.setDominance(this.getDominance());\\n        return objectGene;\\n    }\\n}\",\"Algorithm.java\":\"package indi.uhyils.util.genetic.quadratic;\\n\\nimport indi.uhyils.util.LogUtil;\\nimport indi.uhyils.util.genetic.GeneticAlgorithm;\\nimport indi.uhyils.util.genetic.core.AbstractsInitialization;\\nimport indi.uhyils.util.genetic.core.Data;\\nimport indi.uhyils.util.genetic.core.DnaData;\\nimport indi.uhyils.util.genetic.core.DoubleGene;\\nimport indi.uhyils.util.genetic.core.FitnessFunction;\\nimport indi.uhyils.util.genetic.core.Gene;\\nimport java.util.List;\\n\\n/**\\n * @author uhyils <247452312@qq.com>\\n * @date 文件创建日期 2020年07月31日 09时25分\\n */\\npublic class Algorithm {\\n\\n    public static String cell() {\\n\\n        AbstractsInitialization quadraticDataDataInitialization = new AbstractsInitialization() {\\n\\n\\n            @Override\\n            public Double getDistance(DnaData one, DnaData tow) {\\n                Double a1 = one.getA();\\n                Double b1 = one.getB();\\n\\n                Double a2 = tow.getA();\\n                Double b2 = tow.getB();\\n                double v = (a1 - a2) * (a1 - a2) - (b1 - b2) * (b1 - b2);\\n                return Math.abs(v);\\n            }\\n\\n            @Override\\n            public void variation(DnaData data, Double mutationProbability) {\\n                double v = random.nextDouble();\\n                // 说明中了 要变异\\n                if (v < mutationProbability) {\\n                    List<DoubleGene> genes = data.getGenes();\\n                    int i = random.nextInt(8);\\n                    switch (i) {\\n                        // 变a基因对的第一个基因的性状\\n                        case 0:\\n                            genes.get(0).getOne().setDominance(Gene.getRandomBool());\\n                            break;\\n                        // 变a基因对的第一个基因的值\\n                        case 1:\\n                            genes.get(0).getOne().setValue(Gene.getRandomT(range[0], range[1]));\\n                            break;\\n                        // 变a基因对的第二个基因的性状\\n                        case 2:\\n                            genes.get(0).getTwo().setDominance(Gene.getRandomBool());\\n                            break;\\n                        // 变a基因对的第二个基因的值\\n                        case 3:\\n                            genes.get(0).getTwo().setValue(Gene.getRandomT(range[2], range[3]));\\n                            break;\\n                        // 变b基因对的第一个基因的性状\\n                        case 4:\\n                            genes.get(1).getOne().setDominance(Gene.getRandomBool());\\n                            break;\\n                        // 变b基因对的第一个基因的值\\n                        case 5:\\n                            genes.get(1).getOne().setValue(Gene.getRandomT(range[0], range[1]));\\n                            break;\\n                        // 变b基因对的第二个基因的性状\\n                        case 6:\\n                            genes.get(1).getTwo().setDominance(Gene.getRandomBool());\\n                            break;\\n                        // 变b基因对的第二个基因的值\\n                        case 7:\\n                            genes.get(1).getTwo().setValue(Gene.getRandomT(range[2], range[3]));\\n                            break;\\n                        default:\\n                    }\\n                }\\n            }\\n        };\\n        // 尝试一个拟合二次函数\\n        FitnessFunction<DnaData> quadraticDataFitnessFunction = data -> {\\n            // 目标函数是 a^2 + b = 0\\n            List<DoubleGene> genes = data.getGenes();\\n            Double a = genes.get(0).get();\\n            Double b = genes.get(1).get();\\n            return Math.abs(a * a + b);\\n        };\\n        StringBuilder sb = new StringBuilder();\\n        GeneticAlgorithm geneticAlgorithm = new GeneticAlgorithm(1500, 0.05, quadraticDataFitnessFunction, quadraticDataDataInitialization, 0.5, 0.1);\\n        geneticAlgorithm.init(0.01, -100.0, 100.0, -10000.0, 10000.0);\\n        geneticAlgorithm.iteration(20);\\n        for (Data datum : geneticAlgorithm.getData()) {\\n            DnaData point = (DnaData) datum;\\n            Double a = point.getA();\\n            Double b = point.getB();\\n            String format = String.format(\\\"%f,%f\\\", a, b);\\n            LogUtil.info(format);\\n            sb.append(format);\\n            sb.append(\\\"\\\\n\\\");\\n        }\\n        return sb.toString();\\n    }\\n}\"}', NULL);

-- ----------------------------
-- Table structure for sys_out_api
-- ----------------------------
DROP TABLE IF EXISTS `sys_out_api`;
CREATE TABLE `sys_out_api`  (
  `id` bigint(0) NOT NULL,
  `create_date` bigint(0) NULL DEFAULT NULL,
  `create_user` bigint(0) NULL DEFAULT NULL,
  `delete_flag` bit(1) NULL DEFAULT NULL,
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `update_date` bigint(0) NULL DEFAULT NULL,
  `update_user` bigint(0) NULL DEFAULT NULL,
  `app_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `secret_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `secret_key` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '开放api' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_out_api
-- ----------------------------

SET FOREIGN_KEY_CHECKS = 1;
